#summary This page explains how to write custom patcher for non standard GWT widgets
#sidebar TableOfContents

= Introduction =

The main challenge for _gwt-test-utils_ has been to enable the instanciation of all GWT client side widgets in a standalone JVM and to simulate their behaviours in Java rather than in JavaScript.
This is done by modifying GWT classes as they are loaded in the JVM by a custom classloader *gwt-test-utils* provides to launch JUnit tests.

But don't worry, even if you are interested in writing your own custom bytecode modifications, you will never have to deal with classloading stuff : _gwt-test-utils_ provide a very simple "Patcher" API, which handle all loading and bytecode modification issues behind the scene.

= The Patcher API =
 
Provide a "patch" for an existing class is done in two steps : 
 * write some {{{PatchClass}}} for this class
 * register thoses patch classes to _gwt-test-utils_

== Writing a custom patcher ==


== Registering custom patchers ==

This part is *even more simpler* ! In your {{{META-INF/gwt-test-utils.properties}}} file (which must be available in your test classpath), simply add this line :

{{{
my.patcher.package = scan-class
}}}

As you may have guessed, *my.patcher.package* must by the package of your {{{@PatchClass}}} annotated classes.
Before loading any class, _gwt-test-utils_ will scan every file and directory within {{{my/patcher/package}}} to find classes with the {{{@PatchClass}}} annotation.
You also could have declared {{{my.patcher}}} as the root package to scan, but you should considere performance concerns when scanning a to large number of files.

== Non-trivial patchers ==

In some cases, this example would not suit. This section explains what to do when facing one of them.

==== Patching static methods ====

Assume we want to patch {{{UiObject.isVisible(..)}}} method, which is static :
{{{
public abstract class UIObject {

  public static native boolean isVisible(Element elem) /*-{
    return (elem.style.display != 'none');
  }-*/;
  
}
}}}

It is simply done with this patcher : 


{{{
@PatchClass(UIObject.class)
class UIObjectPatcher {
  
  @PatchMethod
  static boolean isVisible(Element elem) {
    String display = elem.getStyle().getProperty("display");

    return !display.equals("none");
  }
  
}
}}}

The patch method must have exactly the same name and parameters as the original one.
*Just ignore the rule "a patch method must take the initial caller instance as its first parameter" when patching static methods.*


==== Patching private classes ====

You may want to patch a private class. In this case, The annotation parameter {{{@PatchClass(MyPrivateClass.class)}}} won't feet since you can't make a reference to {{{MyPrivateClass}}}.

Well, just use it this way : 

{{{
@PatchClass(classes = {"my.package.MyPrivateClass"})
class MyPrivateClassPatcher {
  ...
}
}}}

*When you want to patch a classes you don't have directly access to, use the {{{classes}}} attribute of {{{@PatchClass}}} which takes a string array representing the name of the classes you want to apply the patcher to.*

==== Overriding existing patchers ====