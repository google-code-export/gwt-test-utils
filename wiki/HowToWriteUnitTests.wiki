#summary This page explains how to write unit tests for GWT with gwt-test-utils

= Samples =

A complete sample application is available through the <a href="http://code.google.com/p/gwt-test-utils/downloads/list">Downloads section</a>.

== Tests on a button ==

Let's create a simple GWT composite which contains a button and a label :

{{{
public class SimpleComposite extends Composite {

   private Button button = new Button();
   private Label label = new Label();

   public SimpleComposite() {

      button.setHTML("display something");

      // The wrapper panel
      VerticalPanel vPanel = new VerticalPanel();
      vPanel.setWidth("100%");
      vPanel.setHorizontalAlignment(VerticalPanel.ALIGN_CENTER);
      vPanel.add(button);
      vPanel.add(label);

      // All composites must call initWidget() in their constructors.
      initWidget(vPanel);

      VerticalPanel dialogVPanel = new VerticalPanel();
      dialogVPanel.setWidth("100%");
      dialogVPanel.setHorizontalAlignment(VerticalPanel.ALIGN_CENTER);

      // Add click handlers to the button
      button.addClickHandler(new ClickHandler() {

         public void onClick(ClickEvent arg0) {
            label.setText("The button was clicked !");
         }
			
      });
   }
}
}}}

When the button is clicked, the label display "_The button was clicked !_". This is very simple and works great when the {{{SimpleComposite}}} is added to GWT {{{RootPanel}}}.

Now, we want to write a unit test to ensure clicking the button always will display "_The button was clicked !_" in the label :

{{{
public class SimpleCompositeTest extends AbstractGWTTest {

   // the tested composite
   private SimpleComposite composite;

   @Before
   public void init() throws Exception {
      // instanciate the composite
      composite = new SimpleComposite();
   }
	
   @Test
   public void checkClick() {
      // With this helper method, we can get private Widget in the composite
      Button button = ReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = ReflectionUtils.getPrivateFieldValue(composite, "label");
		
      // ensure label is empty
      Assert.assertEquals(null, label.getText());
		
      // simule the click event with AbstractGWTTest method
      click(button);
		
      // assert the label has been filled
      Assert.assertEquals("The button was clicked !", label.getText());
   }
}
}}}

Note that the test class *must* extends {{{AbstractGWTTest}}}, which provide the mecanism to allow the instanciation of GWT component in the JVM.

{{{AbstractGWTTest}}} also provide some helpfull method to simule User Event, such as click, double-click, blur, etc.


= Tests with a GWT RPC call =

Frequently, your presentation layer will make server call.
In unit tests, you will need to mock the server calls. _gwt-test-utils_ provides an elegant way to do it with <a href="http://easymock.org/">{{{EasyMock}}}</a>.

First, the service exposed : 

{{{
@RemoteServiceRelativePath("service")
public interface RCPService extends RemoteService {

   public String sayHello(String name);

}
}}}

And the used implementation :

{{{
public class RCPServiceImpl extends RemoteServiceServlet implements RCPService {

   private static final long serialVersionUID = -5691698208719724136L;

   public String sayHello(String name) {
      return "Hello " + name + " !";
   }
	
}
}}}

The corresponding asynchronous interface (which could be generated by GWT tools)

{{{
public interface RCPServiceAsync {
	
   void sayHello(String name, AsyncCallback<String> callback);

}
}}}

Now that we have the server side service, let's code another Composite, also with a button and a label to call this service :

{{{
public class RPCComposite extends Composite {

   private Button button = new Button();
   private Label label = new Label();
	
   // create an instance of the service
   private RCPServiceAsync service = (RCPServiceAsync) GWT.create(RCPService.class);

   public RPCComposite() {
      button.setText("say hello");
		
      //the wrapper panel
      VerticalPanel vPanel = new VerticalPanel();
      vPanel.setWidth("100%");
      vPanel.setHorizontalAlignment(VerticalPanel.ALIGN_CENTER);
      vPanel.add(button);
      vPanel.add(label);

      button.addClickHandler(new ClickHandler() {

         public void onClick(ClickEvent event) {
            // Create an asynchronous callback to handle the result.
            AsyncCallback<String> callback = new AsyncCallback<String>() {

               public void onSuccess(String result) {
                  label.setText(result);
               }

               public void onFailure(Throwable caught) {
                  // Show the RPC error message to the user
                  label.setText("Failure : " + caught.getMessage());
               }
            };

            // Make the call. Control flow will continue immediately and later
            // 'callback' will be invoked when the RPC completes.
            service.sayHello("OCTO", callback);
         }
      });

      // All composites must call initWidget() in their constructors.
      initWidget(vPanel);
   }
}
}}}

Clicking the button will make a server call, to say hello to "OCTO". As a result, the label is supposed to print "Hello OCTO !" if the server call succeeded, or the error message in case the of a failure. 

Let's create unit tests to simule the two possibilities :

{{{
public class RPCCompositeTest extends AbstractGWTEasyMockTest {

   @Mock
   private RCPServiceAsync service;

   private RPCComposite composite;

   @Before
   public void init() throws Exception {
      composite = new RPCComposite();
   }

   @SuppressWarnings("unchecked")
   @Test
   public void checkRPCCallSuccess() {
      //Setup
      Button button = ReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = ReflectionUtils.getPrivateFieldValue(composite, "label");

      service.sayHello(EasyMock.eq("OCTO"), EasyMock.isA(AsyncCallback.class));

      expectServiceAndCallbackOnSuccess("mocked call");
      replay();
      // Test
      Assert.assertEquals(null, label.getText());

      // click to call server back
      click(button);

      // Assert
      verify();
      Assert.assertEquals("mocked call", label.getText());
   }

   @SuppressWarnings("unchecked")
   @Test
   public void checkRPCCallFailure() {
      //Setup
      Button button = ReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = ReflectionUtils.getPrivateFieldValue(composite, "label");

      service.sayHello(EasyMock.eq("OCTO"), EasyMock.isA(AsyncCallback.class));

      expectServiceAndCallbackOnFailure(new Exception("Mocked exception"));
      replay();
      // Test
      Assert.assertEquals(null, label.getText());

      // click to call server back
      click(button);

      // Assert
      verify();
      Assert.assertEquals("Failure : Mocked exception", label.getText());
   }
}
}}}

This time, we extended {{{AbstractGWTEasyMockTest}}}, a subclass of {{{AbstractGWTTest}}} which provide some helpfull methods to inject mock object and use them :

*{{{@Mock}}}* tell _gwt-test-utils_ to create a mock object

*{{{expectServiceAndCallbackOnSuccess(Object result)}}}* tell easymock to make the mocked object return the "result" object as a sucess response to the call.

*{{{expectServiceAndCallbackOnFailure(Throwable t)}}}* tell easymock to make the mocked object return the "t" exception as a failure response to the call.