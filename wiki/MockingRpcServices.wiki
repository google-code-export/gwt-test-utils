#summary Describes how to write unit tests which mock GWT-RPC services calls.
#sidebar TableOfContents


= Mocking GWT-RPC calls =

Frequently, your presentation layer will call remote services using GWT-RPC.
In unit tests, you will need to mock the server calls. *gwt-test-utils* provides an elegant way to do it with [http://easymock.org/ EasyMock].

First, the service exposed : 

{{{
@RemoteServiceRelativePath("service")
public interface RCPService extends RemoteService {

   public String sayHello(String name);

}
}}}

And the used implementation :

{{{
public class RCPServiceImpl extends RemoteServiceServlet implements RCPService {

   private static final long serialVersionUID = -5691698208719724136L;

   public String sayHello(String name) {
      return "Hello " + name + " !";
   }
	
}
}}}

The corresponding asynchronous interface (which could be generated by GWT tools)

{{{
public interface RCPServiceAsync {
	
   void sayHello(String name, AsyncCallback<String> callback);

}
}}}

Now that we have the server side service, let's code another Composite, also with a button and a label to call this service :

{{{
public class RPCComposite extends Composite {

   private Button button = new Button();
   private Label label = new Label();
	
   // create an instance of the service
   private RCPServiceAsync service = (RCPServiceAsync) GWT.create(RCPService.class);

   public RPCComposite() {
      button.setText("say hello");
		
      //the wrapper panel
      VerticalPanel vPanel = new VerticalPanel();
      vPanel.setWidth("100%");
      vPanel.setHorizontalAlignment(VerticalPanel.ALIGN_CENTER);
      vPanel.add(button);
      vPanel.add(label);

      button.addClickHandler(new ClickHandler() {

         public void onClick(ClickEvent event) {
            // Create an asynchronous callback to handle the result.
            AsyncCallback<String> callback = new AsyncCallback<String>() {

               public void onSuccess(String result) {
                  label.setText(result);
               }

               public void onFailure(Throwable caught) {
                  // Show the RPC error message to the user
                  label.setText("Failure : " + caught.getMessage());
               }
            };

            // Make the call. Control flow will continue immediately and later
            // 'callback' will be invoked when the RPC completes.
            service.sayHello("OCTO", callback);
         }
      });

      // All composites must call initWidget() in their constructors.
      initWidget(vPanel);
   }
}
}}}

Clicking the button will make a server call, to say hello to "OCTO". As a result, the label is supposed to print "Hello OCTO !" if the server call succeeded, or the error message in case the of a failure. 

Let's create unit tests to simule the two possibilities :

{{{
public class RPCCompositeTest extends AbstractGwtEasyMockTest {

   @Mock
   private RCPServiceAsync service;

   private RPCComposite composite;

   @Before
   public void init() throws Exception {
      composite = new RPCComposite();
   }

   @SuppressWarnings("unchecked")
   @Test
   public void checkRPCCallSuccess() {
      //Setup
      Button button = GwtTestReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = GwtTestReflectionUtils.getPrivateFieldValue(composite, "label");

      service.sayHello(EasyMock.eq("OCTO"), EasyMock.isA(AsyncCallback.class));

      expectServiceAndCallbackOnSuccess("mocked call");
      replay();
      // Test
      Assert.assertEquals(null, label.getText());

      // click to call server back
      Browser.click(button);

      // Assert
      verify();
      Assert.assertEquals("mocked call", label.getText());
   }

   @SuppressWarnings("unchecked")
   @Test
   public void checkRPCCallFailure() {
      //Setup
      Button button = GwtTestReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = GwtTestReflectionUtils.getPrivateFieldValue(composite, "label");

      service.sayHello(EasyMock.eq("OCTO"), EasyMock.isA(AsyncCallback.class));

      expectServiceAndCallbackOnFailure(new Exception("Mocked exception"));
      replay();
      
      Assert.assertEquals(null, label.getText());

      // Test
      // click to call server back
      Browser.click(button);

      // Assert
      verify();
      Assert.assertEquals("Failure : Mocked exception", label.getText());
   }
}
}}}

This time, we extended {{{AbstractGwtEasyMockTest}}}, a subclass of {{{AbstractGwtTest}}} which provides some helpful methods to inject mock objects and use them :

*{{{@Mock}}}* tell *gwt-test-utils* to create a mock object

*{{{expectServiceAndCallbackOnSuccess(Object result)}}}* tell easymock to make the mocked object return the "result" object as a sucess response to the call.

*{{{expectServiceAndCallbackOnFailure(Throwable t)}}}* tell easymock to make the mocked object return the "t" exception as a failure response to the call.

*{{{replay()}}}* will call {{{EasyMock.replay(..)}}} on each declared {{{@Mock}}} in the test class.

*{{{verify()}}}* will call {{{EasyMock.verify(..)}}} on each declared {{{@Mock}}} in the test class.