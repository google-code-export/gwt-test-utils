#summary Describes how to mock RPC services calls in unit tests.
#sidebar TableOfContents


= Introduction =

Frequently, your presentation layer will call remote services using GWT-RPC.
In unit tests, you will need to mock the server calls. *gwt-test-utils* provides an elegant way to do it, using either the [http://easymock.org/ EasyMock] or the [http://mockito.org/ Mockito] mocking framework.

Mocking RPC services is much like mocking any other classes (see [MockingClasses Mocking classes]), with a few specificities, like asynchronous callback handling. 

= Our application code =

First, the service exposed : 

{{{
@RemoteServiceRelativePath("service")
public interface RCPService extends RemoteService {

   public String sayHello(String name);

}
}}}

And the used implementation :

{{{
public class RCPServiceImpl extends RemoteServiceServlet implements RCPService {

   private static final long serialVersionUID = -5691698208719724136L;

   public String sayHello(String name) {
      return "Hello " + name + " !";
   }
	
}
}}}

The corresponding asynchronous interface (which could be generated by GWT tools)

{{{
public interface RCPServiceAsync {
	
   void sayHello(String name, AsyncCallback<String> callback);

}
}}}

Now that we have the server side service, let's code another Composite, also with a button and a label to call this service :

{{{
public class RPCComposite extends Composite {

   private Button button = new Button();
   private Label label = new Label();
	
   // create an instance of the service
   private RCPServiceAsync service = (RCPServiceAsync) GWT.create(RCPService.class);

   public RPCComposite() {
      button.setText("say hello");
		
      //the wrapper panel
      VerticalPanel vPanel = new VerticalPanel();
      vPanel.setWidth("100%");
      vPanel.setHorizontalAlignment(VerticalPanel.ALIGN_CENTER);
      vPanel.add(button);
      vPanel.add(label);

      button.addClickHandler(new ClickHandler() {

         public void onClick(ClickEvent event) {
            // Create an asynchronous callback to handle the result.
            AsyncCallback<String> callback = new AsyncCallback<String>() {

               public void onSuccess(String result) {
                  label.setText(result);
               }

               public void onFailure(Throwable caught) {
                  // Show the RPC error message to the user
                  label.setText("Failure : " + caught.getMessage());
               }
            };

            // Make the call. Control flow will continue immediately and later
            // 'callback' will be invoked when the RPC completes.
            service.sayHello("OCTO", callback);
         }
      });

      // All composites must call initWidget() in their constructors.
      initWidget(vPanel);
   }
}
}}}

Clicking the button will make a server call, to say hello to "OCTO". As a result, the label is supposed to print "Hello OCTO !" if the server call succeeded, or the error message in case the of a failure. 

= Unit tests using EasyMock =

Let's create unit tests to simulate the two scenarios, using EasyMock for RPC service mocking :

{{{
public class RPCCompositeTest extends GwtTestWithEasyMock {

   @Mock
   private RCPServiceAsync service;

   private RPCComposite composite;

   @Before
   public void init() throws Exception {
      composite = new RPCComposite();
   }

   @Test
   public void checkRPCCallSuccess() {
      //Setup
      Button button = GwtReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = GwtReflectionUtils.getPrivateFieldValue(composite, "label");

      service.sayHello(EasyMock.eq("OCTO"), EasyMock.isA(AsyncCallback.class));

      expectServiceAndCallbackOnSuccess("mocked call");
      replay();
      // Test
      Assert.assertEquals(null, label.getText());

      // click to call server back
      Browser.click(button);

      // Assert
      verify();
      Assert.assertEquals("mocked call", label.getText());
   }

   @Test
   public void checkRPCCallFailure() {
      //Setup
      Button button = GwtReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = GwtReflectionUtils.getPrivateFieldValue(composite, "label");

      service.sayHello(EasyMock.eq("OCTO"), EasyMock.isA(AsyncCallback.class));

      expectServiceAndCallbackOnFailure(new Exception("Mocked exception"));
      replay();
      
      Assert.assertEquals(null, label.getText());

      // Test
      // click to call server back
      Browser.click(button);

      // Assert
      verify();
      Assert.assertEquals("Failure : Mocked exception", label.getText());
   }
}
}}}

*{{{@Mock}}}* tells *gwt-test-utils* to create a mock object using EasyMock.

*{{{expectServiceAndCallbackOnSuccess(Object result)}}}* tells to make the mocked object return the "result" object as a success response to the last call.

*{{{expectServiceAndCallbackOnFailure(Throwable t)}}}* tells to make the mocked object return the "t" exception as a failure response to the last call.

*{{{replay()}}}* will call {{{EasyMock.replay(..)}}} on each declared {{{@Mock}}} in the test class.

*{{{verify()}}}* will call {{{EasyMock.verify(..)}}} on each declared {{{@Mock}}} in the test class.

= Unit tests using Mockito =

Now, let's see how we can achieve the same thing using Mockito.

Things are quite similar, but this time, of course, with a Mockito-like syntax :

{{{
public class RPCCompositeTest extends GwtTestWithMockito {

   @Mock
   private RCPServiceAsync service;

   private RPCComposite composite;

   @Before
   public void init() throws Exception {
      composite = new RPCComposite();
   }

   @Test
   public void checkRPCCallSuccess() {
      //Setup
      Button button = GwtReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = GwtReflectionUtils.getPrivateFieldValue(composite, "label");

      doSuccessCallback("mocked call").when(service).sayHello(eq("OCTO"), any(AsyncCallback.class));

      // Test
      Assert.assertEquals(null, label.getText());

      // click to call server back
      Browser.click(button);

      // Assert
      verify(service).sayHello(eq("OCTO"), any(AsyncCallback.class));
      Assert.assertEquals("mocked call", label.getText());
   }

   @Test
   public void checkRPCCallFailure() {
      //Setup
      Button button = GwtReflectionUtils.getPrivateFieldValue(composite, "button");
      Label label = GwtReflectionUtils.getPrivateFieldValue(composite, "label");

      service.sayHello(EasyMock.eq("OCTO"), EasyMock.isA(AsyncCallback.class));

      doFailureCallback(new Exception("Mocked exception")).when(service).sayHello(eq("OCTO"), any(AsyncCallback.class));

      Assert.assertEquals(null, label.getText());

      // Test
      // click to call server back
      Browser.click(button);

      // Assert
      verify(service).sayHello(eq("OCTO"), any(AsyncCallback.class));
      Assert.assertEquals("Failure : Mocked exception", label.getText());
   }
}
}}}

*{{{@Mock}}}* tells *gwt-test-utils* to create a mock object using Mockito. Both gwt-test-utils or Mockito annotation can be used.

*{{{doSuccessCallback(Object result)}}}* tells to make the mocked object return the "result" object as a success response.

*{{{doFailureCallback(Throwable t)}}}* tells to make the mocked object return the "t" exception as a failure response.

*{{{verify()}}}* is a Mockito static method to check a method was actually call with expected parameters.